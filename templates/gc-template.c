#include "list.h"
#include "gc.h"

#include <stdint.h>
#include <stdio.h>

/**
 * Input a template (list of numbers), returns its possible templates (list of list).
 */
static void *generate(void *context, void *list);

// make unsigned number object
static void *number_make(unsigned value);

// interpret value object as unsigned number
static unsigned as_number(void *value);

// print out given template.
static void *dump_template(void *context, void *aggregate, void *list);

int main()
{
    GC_INIT();
    fprintf(stdout, "/* This sudoku template generated by `gc-template`. */\n");
    struct list *templates = generate(NULL, list_make(NULL, 0));
    list_reduce(templates, stdout, dump_template, NULL);
    fflush(stdout);
    return 0;
}

static void *dump_number(void *context, void *aggregate, void *value);

void *dump_template(void *context, void *file, void *list)
{
    fprintf(file, "{");
    list_reduce(list, file, dump_number, context);
    fprintf(file, "},\n");
    return file;
}

void *dump_number(void *context, void *file, void *value)
{
    fprintf(file, " %u,", as_number(value));
    return file;
}

static struct list *candidates(struct list *list);
static struct list *prune(struct list *lists);
static struct list *flatten(struct list *lists);

void *generate(void *context, void *list)
{
    if (list_length(list) == 9)
    {
        return list_make(&list, 1);
    }
    else
    {
        struct list *nexts = candidates(list);
        struct list *filtered = prune(nexts);
        struct list *lists = list_map(filtered, generate, context);
        return flatten(lists);
    }
}

struct list *candidates(struct list *list)
{
    /* make {list ++ [9N], list ++ [9N+1], ..., list ++ [9N+8]} */
    unsigned const n = list_length(list);
#define N(i) number_make(9 * n + i)
    void *ns[9] = {N(0), N(1), N(2), N(3), N(4), N(5), N(6), N(7), N(8)};
#undef N
    void *(*const prepend)(void *, void*) = (void *)list_append;
    return list_map(list_make(ns, 9), prepend, list);
}

static bool follows_constraints(void *context, void *value);

struct list *prune(struct list *lists)
{
    return list_filter(lists, follows_constraints, NULL);
}

static bool no_duplicate(void *(*constraints)(void *context, void *value), struct list *list, void *context);
static void *column_number(void *context, void *value);
static void *block_number(void *context, void *value);

bool follows_constraints(void *context, void *list)
{
    switch (list_length(list))
    {
    case 0:
    case 1:
        return true;
    default:
        return no_duplicate(column_number, list, context) && no_duplicate(block_number, list, context);
    }
}

static bool eq(void *context, void *value);

bool no_duplicate(void *(*group)(void *context, void *value), struct list *list, void *context)
{
    struct list *number = list_map(list, group, context);
    void *the_last = list_value(number, list_length(number) - 1);
    return list_length(list_filter(number, eq, the_last)) == 1;
}

void *column_number(void *context, void *value)
{
    return number_make(as_number(value) % 9);
}

void *block_number(void *context, void *value)
{
    return number_make(as_number(value) / 3 % 3 + as_number(value) / 27 * 3);
}

bool eq(void *context, void *value)
{
    return as_number(context) == as_number(value);
}

static void *concat(void *context, void *aggregate, void *list);

struct list *flatten(struct list *lists)
{
    return list_reduce(lists, list_make(NULL, 0), concat, NULL);
}

void *concat(void *context, void *aggregate, void *list)
{
    return list_concatenate(aggregate, list);
}

void *number_make(unsigned value)
{
    return (void*)(uintptr_t)value;
}

unsigned as_number(void *value)
{
    return (uintptr_t)value;
}
